{
  "filename": "ut-guideline.md",
  "__html": "<h1>Unit Test Guideline</h1>\n<blockquote>\n<p>部分内容参考自《Unit Testing Principles, Practices, and Patterns》</p>\n</blockquote>\n<h2>1. 单元测试架构</h2>\n<h3>1.1 如何构建单元测试？</h3>\n<blockquote>\n<p>本节将展示如何通过 3A 原则来构建单元测试，应当避免哪些缺陷，以及如何使测试更具有可读性。</p>\n</blockquote>\n<h4>1.1.1 3A 原则</h4>\n<p>3A 原则简单易懂，它为套件中的所有测试提供了统一的结构，这种统一的结构是其最大的优势之一：一旦习惯了这种模式，就可以更轻松地阅读和理解测试，这反过来又降低了整个测试套件的维护成本。</p>\n<ul>\n<li>Arrange：初始化测试数据。</li>\n<li>Act：调用被测方法，传入依赖参数并获取返回值。</li>\n<li>Assert：断言，对返回值做出断言。</li>\n</ul>\n<p>示例：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Calculator</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">long</span> <span class=\"hljs-title\">sum</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">long</span> a, <span class=\"hljs-keyword\">long</span> b)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> a + b;\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CalculatorTest</span> </span>{\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sum</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// Arrange</span>\n        <span class=\"hljs-keyword\">long</span> a = <span class=\"hljs-number\">1L</span>, b = <span class=\"hljs-number\">2L</span>;\n        Calculator calculator = <span class=\"hljs-keyword\">new</span> Calculator();\n        <span class=\"hljs-comment\">// Act</span>\n        <span class=\"hljs-keyword\">long</span> actual = calculator.sum(a, b);\n        <span class=\"hljs-comment\">// Assert</span>\n        <span class=\"hljs-keyword\">long</span> expected = <span class=\"hljs-number\">3L</span>;\n        assertEquals(expected, actual);\n    }\n}\n</code></pre>\n<p>从 <code>arrange</code> 或 <code>assert</code> 开始编写单元测试都是可行的。当采用 TDD（Test-Driven Development，测试驱动开发）思想进行开发时，由于是在开发特性之前编写单元测试，因此对特性的细节并没有完全了解，此时应当首先理清期望从中得到的结果是什么，进而再思考如何满足这些期望，此时更加推荐从 <code>assert</code> 开始编写单元测试。当然，如果并没有遵循 TDD 思想，也就是在编写单元测试之前业务代码已经实现，那么这时候更推荐从 <code>arrange</code> 开始编写单元测试。</p>\n<h4>1.1.2 避免多重 Arrage, Act, Assert 嵌套</h4>\n<p><img src=\"/img/unit-test/ut-nested-3a.png\" alt=\"nested-3a\"></p>\n<p>多重 Arrange, Act, Assert 意味着该测试正在验证多个行为单元，那么它就不再是单元测试，而是集成测试了。此时应当将这种测试分解成多个测试，使单元测试更加简单、快速且易于理解。</p>\n<h4>1.1.3 避免使用 <code>if</code> 条件语句</h4>\n<p>无论是单元测试还是集成测试，都应该是一个没有分支的、简单的步骤序列，而 <code>if</code> 语句表明在一次测试中验证了多种情况，因此，同样应该将这种测试分解成多个测试。</p>\n<h4>1.1.4 删除 arrange, act, assert 的注释</h4>\n<p>区分 arrange、act、assert 三部分可以提高可读性。可以通过以下两种方式进行区分：</p>\n<ol>\n<li>\n<p>在每部分的开始添加注释来表明是哪一部分。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// arrange</span>\nCalculator calculator = <span class=\"hljs-keyword\">new</span> Calculator();\n<span class=\"hljs-comment\">// act</span>\n<span class=\"hljs-keyword\">long</span> actual = calculator.sum(<span class=\"hljs-number\">1L</span>, <span class=\"hljs-number\">2L</span>);\n<span class=\"hljs-comment\">// assert</span>\nassertEquals(<span class=\"hljs-number\">3L</span>, actual);\n</code></pre>\n</li>\n<li>\n<p>在各部分之间添加空行。</p>\n</li>\n</ol>\n<h3>1.2 单元测试命名</h3>\n<p>首先，单元测试的名称是否具有表达性是很重要的，合适的名称可以让人们快速理解这个测试的目的和结果。</p>\n<p>推荐使用下列命名方式：</p>\n<pre><code>[MethodUnderTest]_[Scenario]_[ExpectedResult]\n</code></pre>\n<ul>\n<li><code>MethodUnderTest</code>：被测试方法名。</li>\n<li><code>Scenario</code>：测试方法的条件。</li>\n<li><code>ExpectedResult</code>：在上述条件下所期望的结果。</li>\n</ul>\n<p>如测试 <code>isAdult()</code> 方法：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isAdult</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> age)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (age &lt; <span class=\"hljs-number\">0</span> || age &gt; <span class=\"hljs-number\">120</span>) {\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">&quot;The age is illegal&quot;</span>);\n    }\n    <span class=\"hljs-keyword\">return</span> age &gt;= <span class=\"hljs-number\">18</span>;\n}\n</code></pre>\n<p><code>isAdult</code> 测试方法命名：</p>\n<pre><code>isAdult_MoreThan18_ReturnTrue\t// 大于 18 岁 =&gt; 是成年人\nisAdult_LessThan0_ThrowIllegalArgumentException\t// 小于 0 岁 =&gt; 非法输入\n</code></pre>\n<p>此外，还需注意一下几点：</p>\n<ol>\n<li>不要遵循严格的命名方式。因为有时很难在方法名中描述复杂的情况。</li>\n<li>用下划线分隔单词。 这样做有助于提高可读性。</li>\n</ol>\n<h2>2. 单元测试风格</h2>\n<p>三种单元测试风格：</p>\n<ul>\n<li><code>output-based style</code>，基于输出结果的测试风格</li>\n<li><code>state-based style</code>，基于状态的测试风格</li>\n<li><code>communication-based style</code>，基于通信的测试风格</li>\n</ul>\n<h3>2.1 output-based style</h3>\n<p>该测试风格如下图所示，在输入参数之后对业务代码的输出结果进行验证。该测试风格只适用于测试不会改变全局或内部状态的业务代码，因此只需验证其返回值即可。</p>\n<p><img src=\"/img/unit-test/ut-output-based-style.png\" alt=\"output-based-style\"></p>\n<p>示例：</p>\n<p><code>calculateDiscount()</code> 方法用于计算一组物品的折扣。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PriceEngine</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">double</span> <span class=\"hljs-title\">calculateDiscount</span><span class=\"hljs-params\">(Product[] products)</span> </span>{\n        <span class=\"hljs-keyword\">double</span> discount = products.length * <span class=\"hljs-number\">0.01</span>;\n        <span class=\"hljs-keyword\">return</span> Math.min(discount, <span class=\"hljs-number\">0.02</span>);\n    }\n}\n</code></pre>\n<p><code>output-based</code> 风格的单元测试：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PriceEngineTest</span> </span>{\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">calculateDiscount_MinimumDiscount_ReturnMinimumDiscount</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// arrange</span>\n\t\tProduct product1 = <span class=\"hljs-keyword\">new</span> Product(<span class=\"hljs-string\">&quot;Hand wash&quot;</span>);\n        Product product2 = <span class=\"hljs-keyword\">new</span> Product(<span class=\"hljs-string\">&quot;Shampoo&quot;</span>);\n        PriceEngine priceEngine = <span class=\"hljs-keyword\">new</span> PriceEngine();\n        Product[] products = <span class=\"hljs-keyword\">new</span> Product[]{product1, product2};\n        <span class=\"hljs-comment\">// act</span>\n        <span class=\"hljs-keyword\">double</span> discount = priceEngine.calculateDiscount(products);\n        <span class=\"hljs-comment\">// assert</span>\n        Assert.assertEquals(<span class=\"hljs-number\">0.02</span>, discount);\n    }\n}\n</code></pre>\n<h3>2.2 state-based style</h3>\n<p>该测试风格如下图所示，在操作完成后验证系统的最终状态。其中，“状态”一词可以指单元测试本身，也可以指数据库、文件系统等外部依赖。</p>\n<p><img src=\"/img/unit-test/ut-state-based-style.png\" alt=\"state-based-style\"></p>\n<p>示例：</p>\n<p><code>addProduct()</code> 方法用于向订单中添加一个物品。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Order</span> </span>{\n    <span class=\"hljs-keyword\">public</span> List&lt;Product&gt; products = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">addProduct</span><span class=\"hljs-params\">(Product product)</span> </span>{\n        products.add(product);\n    }\n}\n</code></pre>\n<p><code>state-based</code> 风格的单元测试：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">OrderTest</span> </span>{\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">addProduct_AddAProduct</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// arrange</span>\n        Product product = <span class=\"hljs-keyword\">new</span> Product(<span class=\"hljs-string\">&quot;Hand wash&quot;</span>);\n        Order order = <span class=\"hljs-keyword\">new</span> Order();\n        <span class=\"hljs-comment\">// act</span>\n        order.addProduct(product);\n        <span class=\"hljs-comment\">// assert</span>\n        Assert.assertEquals(<span class=\"hljs-number\">1</span>, order.products.size());\n        Assert.assertEquals(product, order.products.get(<span class=\"hljs-number\">0</span>));\n    }\n}\n</code></pre>\n<blockquote>\n<p>与 <code>output-based style</code> 不同，<code>addProduct()</code> 方法的结果会导致订单状态的更改。</p>\n</blockquote>\n<h3>2.3 communication-based style</h3>\n<p>该测试风格如下图所示，使用 mock 验证待测部分是否能够正确调用其他模块。</p>\n<p><img src=\"/img/unit-test/ut-communication-based-style.png\" alt=\"ut-communication-based-style\"></p>\n<p>示例：</p>\n<p><code>greetUser()</code> 方法用于发送问候邮件。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">EmailSender</span> </span>{\n    \n    <span class=\"hljs-keyword\">private</span> SendService service;\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">EmailSender</span><span class=\"hljs-params\">(SendService service)</span> </span>{\n\t\t<span class=\"hljs-keyword\">this</span>.service = service;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">greetUser</span><span class=\"hljs-params\">(String email)</span> </span>{\n        String message = <span class=\"hljs-string\">&quot;Hello!&quot;</span>;\n        <span class=\"hljs-keyword\">return</span> service.send(email, message);\n    }\n}\n</code></pre>\n<p><code>communication-based</code> 风格的单元测试：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">EmailSenderTest</span> </span>{\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">greetUser</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// arrange</span>\n        SendService service = Mockito.mock(SendService.class);\n        EmailSender sender = <span class=\"hljs-keyword\">new</span> EmailSender(service);\n        String email = <span class=\"hljs-string\">&quot;user@email.com&quot;</span>;\n        when(service.send(email, Mockito.anyString())).thenReturn(<span class=\"hljs-keyword\">true</span>);\n        <span class=\"hljs-comment\">// act</span>\n        <span class=\"hljs-keyword\">boolean</span> actual = sender.greetUser(email);\n        <span class=\"hljs-comment\">// assert</span>\n        Assert.assertEquals(<span class=\"hljs-keyword\">true</span>, actual);\n    }\n}\n</code></pre>\n<h3>2.4 对比</h3>\n<p>一个好的单元测试通常基于以下四种属性进行考量：</p>\n<ul>\n<li>\n<p>防止回归</p>\n</li>\n<li>\n<p>重构成本</p>\n</li>\n<li>\n<p>快速反馈</p>\n</li>\n<li>\n<p>可维护性</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">output-based style</th>\n<th style=\"text-align:center\">state-based style</th>\n<th style=\"text-align:center\">communication-based style</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">重构成本</td>\n<td style=\"text-align:center\">低</td>\n<td style=\"text-align:center\">中</td>\n<td style=\"text-align:center\">中</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">维护成本</td>\n<td style=\"text-align:center\">低</td>\n<td style=\"text-align:center\">中</td>\n<td style=\"text-align:center\">高</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>三种风格在防止回归和快速反馈方面表现相同。</p>\n</blockquote>\n<p>经过对比，<code>output-based</code> 风格是最合适的。基于该风格的单元测试很少与实现细节耦合在一起，因此重构成本较小。同时由于该风格所具有的简洁、不依赖于外部环境等特性，因此更具有可维护性。</p>\n<p><code>state-based</code> 和 <code>communication-based</code> 风格的单元测试与实现细节的耦合度更高，因此更难以重构。并且它们代码量往往更大，从而导致更高的维护成本。</p>\n<p>综上，更推荐基于 <code>output-based</code> 风格编写单元测试。</p>\n<h2>3. 反例</h2>\n<h3>3.1 不要为了测试而更改 private 状态</h3>\n<p>原则上应当只针对 public API 进行测试。通常 private 方法只完成很小一部分功能，它是短小精悍的，虽然可以通过反射等技术实现对 private 方法的测试，但是这将会使测试变的繁琐而且更难维护，因此大多时候无需单独测试  private 方法。</p>\n<p>若 private 方法确实需要进行直接测试，也不要为了测试而更改 private 状态。可以使用下面两种方式实现：</p>\n<ol>\n<li>\n<p>设计测试用例，通过测试 public API 间接测试 private 方法。</p>\n</li>\n<li>\n<p>将 private 方法重构成工具类的 public 方法。</p>\n<blockquote>\n<p>这么做是为了改善设计，而不是帮助测试。</p>\n</blockquote>\n</li>\n</ol>\n<p>以第二种方式为例：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Order</span> </span>{\n    <span class=\"hljs-keyword\">private</span> Customer customer;\n    <span class=\"hljs-keyword\">private</span> List&lt;Product&gt; products;\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">generateDescription</span><span class=\"hljs-params\">()</span> </span>{\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Customer name: &quot;</span> + customer.getName() + <span class=\"hljs-string\">&quot;, total price: &quot;</span> + getPrice();\n    }\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">double</span> <span class=\"hljs-title\">getPrice</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">double</span> basePrice;\t<span class=\"hljs-comment\">// 基于 products 计算</span>\n        <span class=\"hljs-keyword\">double</span> discounts;\t<span class=\"hljs-comment\">// 基于 customer 计算</span>\n        <span class=\"hljs-keyword\">double</span> taxes;\t<span class=\"hljs-comment\">// 基于 products 计算</span>\n        <span class=\"hljs-comment\">// do some calculation</span>\n        <span class=\"hljs-keyword\">return</span> basePrice - discounts + taxes;\n    }\n}\n</code></pre>\n<p>其中，公有的 <code>generateDescription()</code> 方法非常简单，只是返回一个订单的信息，但是它所调用的私有的 <code>getPrice()</code> 方法却非常复杂。<code>getPrice()</code> 方法包含了重要的业务逻辑，因此需要进行全面测试。</p>\n<p>为了测试 <code>getPrice()</code> 方法，应当将其重构到单独一个类中。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Order</span> </span>{\n    <span class=\"hljs-keyword\">private</span> Customer customer;\n    <span class=\"hljs-keyword\">private</span> List&lt;Product&gt; products;\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">generateDescription</span><span class=\"hljs-params\">()</span> </span>{\n        PriceCalculator calc = <span class=\"hljs-keyword\">new</span> PriceCalculator();\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Customer name: &quot;</span> + customer.getName() +\n            <span class=\"hljs-string\">&quot;, total price: &quot;</span> + calc.getPrice(customer, products);\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PriceCalculator</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">double</span> <span class=\"hljs-title\">getPrice</span><span class=\"hljs-params\">(Customer customer, List&lt;Product&gt; products)</span> </span>{\n        <span class=\"hljs-keyword\">double</span> basePrice;\t<span class=\"hljs-comment\">// 基于 products 计算</span>\n        <span class=\"hljs-keyword\">double</span> discounts;\t<span class=\"hljs-comment\">// 基于 customer 计算</span>\n        <span class=\"hljs-keyword\">double</span> taxes;\t<span class=\"hljs-comment\">// 基于 products 计算</span>\n        <span class=\"hljs-comment\">// do some calculation</span>\n        <span class=\"hljs-keyword\">return</span> basePrice - discounts + taxes;\n    }\n}\n</code></pre>\n<p>这样，就可以不依赖于 <code>Order</code> 类实现 <code>PriceCalculator</code> 类的测试了。另外，由于 <code>getPrice()</code> 方法并没有改变任何状态，因此可以基于 <code>output-based</code> 风格编写该方法的单元测试。</p>\n<h3>3.2 测试中不要涉及业务代码逻辑</h3>\n<blockquote>\n<p>这种情况通常发生在涉及复杂算法的测试中。</p>\n</blockquote>\n<p>以一个简单的例子说明这种情况：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CalculatorTest</span> </span>{\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sum</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// arrange</span>\n        <span class=\"hljs-keyword\">long</span> a = <span class=\"hljs-number\">1L</span>, b = <span class=\"hljs-number\">2L</span>;\n        Calculator calculator = <span class=\"hljs-keyword\">new</span> Calculator();\n        <span class=\"hljs-comment\">// act</span>\n        <span class=\"hljs-keyword\">long</span> actual = calculator.sum(a, b);\n        <span class=\"hljs-comment\">// assert</span>\n        <span class=\"hljs-keyword\">long</span> expected = a + b;\t<span class=\"hljs-comment\">// 反例</span>\n        <span class=\"hljs-keyword\">long</span> expected = <span class=\"hljs-number\">3L</span>;\t<span class=\"hljs-comment\">// 正例</span>\n        assertEquals(expected, actual);\n    }\n}\n</code></pre>\n<p>在编写单元测试时，应当将待测方法看成一个黑盒。</p>\n<h3>3.3 代码污染</h3>\n<p>代码污染是指添加仅用于测试的生产代码。它将测试代码和业务代码混合在一起，增加了维护成本。</p>\n<p>示例：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Logger</span> </span>{\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">boolean</span> isTestEnvironment;\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Logger</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">boolean</span> isTestEnvironment)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.isTestEnvironment = isTestEnvironment;\n    }\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">log</span><span class=\"hljs-params\">(String text)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (!isTestEnvironment) {\n            <span class=\"hljs-comment\">// log the text</span>\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Controller</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">someMethod</span><span class=\"hljs-params\">(Logger logger)</span> </span>{\n        logger.log(<span class=\"hljs-string\">&quot;someMethod is called&quot;</span>);\n    }\n}\n</code></pre>\n<p>在 <code>Logger</code> 中，参数 <code>isTestEnvironment</code> 变量表明当前是否运行在测试环境中，并通过构造函数传入。通过该变量可以在测试中灵活的控制日志打印，如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ControllerTest</span> </span>{\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> someMethod_LogText_logNothing {\n        Logger logger = <span class=\"hljs-keyword\">new</span> Logger(<span class=\"hljs-keyword\">true</span>);\t<span class=\"hljs-comment\">// 设置为 true，表明当前处于测试环境</span>\n        Controller controller = <span class=\"hljs-keyword\">new</span> Controller();\n        \n        controller.someMethod(logger);\n        \n        <span class=\"hljs-comment\">// assert it won&#x27;t log nothing</span>\n    }\n}\n</code></pre>\n<p>示例中，首先创建了 <code>Logger</code> 类，并传入参数表明当前处于测试环境。但是如果 <code>Logger</code> 类的构造方法或参数一旦跟随业务变化而发生变动，所有涉及 <code>Logger</code> 类的单元测试都需要修改，从而增加了维护成本。</p>\n<p>可以通过接口划分为两类 Logger 来解决这个问题。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">Logger</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">log</span><span class=\"hljs-params\">(String text)</span></span>;\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LoggerImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Logger</span> </span>{\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">log</span><span class=\"hljs-params\">(String text)</span> </span>{\n        <span class=\"hljs-comment\">// log the text</span>\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FakeLoggerImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Logger</span> </span>{\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">log</span><span class=\"hljs-params\">(String text)</span> </span>{\n        <span class=\"hljs-comment\">// do nothing</span>\n    }\n}\n</code></pre>\n<p>这样，在测试时只需创建一个 <code>FakeLoggerImpl</code> 对象即可，即使打印日志的逻辑发生变化，也无需修改测试代码。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ControllerTest</span> </span>{\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> someMethod_LogText_logNothing {\n        Logger logger = <span class=\"hljs-keyword\">new</span> FakeLoggerImpl();\t<span class=\"hljs-comment\">// 创建一个专门用于单元测试的 Logger 对象</span>\n        Controller controller = <span class=\"hljs-keyword\">new</span> Controller();\n        \n        controller.someMethod(logger);\n        \n        <span class=\"hljs-comment\">// assert it won&#x27;t log nothing</span>\n    }\n}\n</code></pre>\n",
  "link": "/dist/zh-cn/blog/ut-guideline.html",
  "meta": {}
}